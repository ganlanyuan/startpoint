// ========== MODERNIZR ==========
/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-boxshadow-flexbox-multiplebgs-opacity-rgba-cssanimations-cssgradients-csstransforms-csstransforms3d-csstransitions-inlinesvg-svg-cssclasses-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes-css_calc
 */
;window.Modernizr=function(a,b,c){function B(a){j.cssText=a}function C(a,b){return B(m.join(a+";")+(b||""))}function D(a,b){return typeof a===b}function E(a,b){return!!~(""+a).indexOf(b)}function F(a,b){for(var d in a){var e=a[d];if(!E(e,"-")&&j[e]!==c)return b=="pfx"?e:!0}return!1}function G(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:D(f,"function")?f.bind(d||b):f}return!1}function H(a,b,c){var d=a.charAt(0).toUpperCase()+a.slice(1),e=(a+" "+o.join(d+" ")+d).split(" ");return D(b,"string")||D(b,"undefined")?F(e,b):(e=(a+" "+p.join(d+" ")+d).split(" "),G(e,b,c))}var d="2.8.3",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k,l={}.toString,m=" -webkit- -moz- -o- -ms- ".split(" "),n="Webkit Moz O ms",o=n.split(" "),p=n.toLowerCase().split(" "),q={svg:"http://www.w3.org/2000/svg"},r={},s={},t={},u=[],v=u.slice,w,x=function(a,c,d,e){var f,i,j,k,l=b.createElement("div"),m=b.body,n=m||b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),l.appendChild(j);return f=["&#173;",'<style id="s',h,'">',a,"</style>"].join(""),l.id=h,(m?l:n).innerHTML+=f,n.appendChild(l),m||(n.style.background="",n.style.overflow="hidden",k=g.style.overflow,g.style.overflow="hidden",g.appendChild(n)),i=c(l,a),m?l.parentNode.removeChild(l):(n.parentNode.removeChild(n),g.style.overflow=k),!!i},y=function(){function d(d,e){e=e||b.createElement(a[d]||"div"),d="on"+d;var f=d in e;return f||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(d,""),f=D(e[d],"function"),D(e[d],"undefined")||(e[d]=c),e.removeAttribute(d))),e=null,f}var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return d}(),z={}.hasOwnProperty,A;!D(z,"undefined")&&!D(z.call,"undefined")?A=function(a,b){return z.call(a,b)}:A=function(a,b){return b in a&&D(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=v.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(v.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(v.call(arguments)))};return e}),r.flexbox=function(){return H("flexWrap")},r.rgba=function(){return B("background-color:rgba(150,255,150,.5)"),E(j.backgroundColor,"rgba")},r.multiplebgs=function(){return B("background:url(https://),url(https://),red url(https://)"),/(url\s*\(.*?){3}/.test(j.background)},r.boxshadow=function(){return H("boxShadow")},r.opacity=function(){return C("opacity:.55"),/^0.55$/.test(j.opacity)},r.cssanimations=function(){return H("animationName")},r.cssgradients=function(){var a="background-image:",b="gradient(linear,left top,right bottom,from(#9f9),to(white));",c="linear-gradient(left top,#9f9, white);";return B((a+"-webkit- ".split(" ").join(b+a)+m.join(c+a)).slice(0,-a.length)),E(j.backgroundImage,"gradient")},r.csstransforms=function(){return!!H("transform")},r.csstransforms3d=function(){var a=!!H("perspective");return a&&"webkitPerspective"in g.style&&x("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}",function(b,c){a=b.offsetLeft===9&&b.offsetHeight===3}),a},r.csstransitions=function(){return H("transition")},r.svg=function(){return!!b.createElementNS&&!!b.createElementNS(q.svg,"svg").createSVGRect},r.inlinesvg=function(){var a=b.createElement("div");return a.innerHTML="<svg/>",(a.firstChild&&a.firstChild.namespaceURI)==q.svg};for(var I in r)A(r,I)&&(w=I.toLowerCase(),e[w]=r[I](),u.push((e[w]?"":"no-")+w));return e.addTest=function(a,b){if(typeof a=="object")for(var d in a)A(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},B(""),i=k=null,e._version=d,e._prefixes=m,e._domPrefixes=p,e._cssomPrefixes=o,e.hasEvent=y,e.testProp=function(a){return F([a])},e.testAllProps=H,e.testStyles=x,g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+u.join(" "):""),e}(this,this.document),Modernizr.addTest("csscalc",function(){var a="width:",b="calc(10px);",c=document.createElement("div");return c.style.cssText=a+Modernizr._prefixes.join(b+a),!!c.style.length});

(function (window, undefined) {
    "use strict";
    // test for REM unit support
    var cssremunit =  function() {
        var div = document.createElement( 'div' );
            div.style.cssText = 'font-size: 1rem;';

        return (/rem/).test(div.style.fontSize);
    },

    // filter returned links for stylesheets
    isStyleSheet = function () {
        var styles = document.getElementsByTagName('link'),
            filteredLinks = [];

        for ( var i = 0; i < styles.length; i++) {
            if ( styles[i].rel.toLowerCase() === 'stylesheet' && styles[i].getAttribute('data-norem') === null ) {

                filteredLinks.push( styles[i].href );
            }
        }

        return filteredLinks;
    },

   processLinks = function () {
        //prepare to match each link
        for( var i = 0; i < links.length; i++ ){
            xhr( links[i], storeCSS );
        }
    },

    storeCSS = function ( response, link ) {

        preCSS.push(response.responseText);
        CSSLinks.push(link);

        if( CSSLinks.length === links.length ){
            for( var j = 0; j <  CSSLinks.length; j++ ){
                matchCSS( preCSS[j], CSSLinks[j] );
            }

            if( ( links = importLinks.slice(0) ).length > 0 ){ //after finishing all current links, set links equal to the new imports found
                CSSLinks = [];
                preCSS = [];
                importLinks = [];
                processLinks();
            } else {
                buildCSS();
            }
        }
    },

    matchCSS = function ( sheetCSS, link ) { // collect all of the rules from the xhr response texts and match them to a pattern
        var clean = removeMediaQueries( sheetCSS ).replace(/\/\*[\s\S]*?\*\//g, ''), // remove MediaQueries and comments
            pattern = /[\w\d\s\-\/\\\[\]:,.'"*()<>+~%#^$_=|@]+\{[\w\d\s\-\/\\%#:!;,.'"*()]+\d*\.?\d+rem[\w\d\s\-\/\\%#:!;,.'"*()]*\}/g, //find selectors that use rem in one or more of their rules
            current = clean.match(pattern),
            remPattern =/\d*\.?\d+rem/g,
            remCurrent = clean.match(remPattern),
            sheetPathPattern = /(.*\/)/,
            sheetPath = sheetPathPattern.exec(link)[0], //relative path to css file specified in @import
            importPattern = /@import (?:url\()?['"]?([^'\)"]*)['"]?\)?[^;]*/gm, //matches all @import variations outlined at: https://developer.mozilla.org/en-US/docs/Web/CSS/@import
            importStatement;

        while( (importStatement = importPattern.exec(sheetCSS)) !== null ){
            importLinks.push( sheetPath + importStatement[1] );
        }

        if( current !== null && current.length !== 0 ){
            found = found.concat( current ); // save all of the blocks of rules with rem in a property
            foundProps = foundProps.concat( remCurrent ); // save all of the properties with rem
        }
    },

    buildCSS = function () { // first build each individual rule from elements in the found array and then add it to the string of rules.
        var pattern = /[\w\d\s\-\/\\%#:,.'"*()]+\d*\.?\d+rem[\w\d\s\-\/\\%#:!,.'"*()]*[;}]/g; // find properties with rem values in them
        for( var i = 0; i < found.length; i++ ){
            rules = rules + found[i].substr(0,found[i].indexOf("{")+1); // save the selector portion of each rule with a rem value
            var current = found[i].match( pattern );
            for( var j = 0; j<current.length; j++ ){ // build a new set of with only the selector and properties that have rem in the value
                rules = rules + current[j];
                if( j === current.length-1 && rules[rules.length-1] !== "}" ){
                    rules = rules + "\n}";
                }
            }
        }

        parseCSS();
    },

    parseCSS = function () { // replace each set of parentheses with evaluated content
        for( var i = 0; i < foundProps.length; i++ ){
            css[i] = Math.round( parseFloat(foundProps[i].substr(0,foundProps[i].length-3)*fontSize) ) + 'px';
        }

        loadCSS();
    },

    loadCSS = function () { // replace and load the new rules
        for( var i = 0; i < css.length; i++ ){ // only run this loop as many times as css has entries
            if( css[i] ){
                rules = rules.replace( foundProps[i],css[i] ); // replace old rules with our processed rules
            }
        }
        var remcss = document.createElement( 'style' );
        remcss.setAttribute( 'type', 'text/css' );
        remcss.id = 'remReplace';
        document.getElementsByTagName( 'head' )[0].appendChild( remcss );   // create the new element
        if( remcss.styleSheet ) {
            remcss.styleSheet.cssText = rules; // IE8 will not support innerHTML on read-only elements, such as STYLE
        } else {
            remcss.appendChild( document.createTextNode( rules ) );
        }
    },

    xhr = function ( url, callback ) { // create new XMLHttpRequest object and run it
        try {
            //try to create a request object
            //arranging the two conditions this way is for IE7/8's benefit
            //so that it works with any combination of ActiveX or Native XHR settings, 
            //as long as one or the other is enabled; but if both are enabled
            //it prefers ActiveX, which means it still works with local files
            //(Native XHR in IE7/8 is blocked and throws "access is denied",
            // but ActiveX is permitted if the user allows it [default is to prompt])
            var xhr = window.ActiveXObject ? ( new ActiveXObject('Microsoft.XMLHTTP') || new ActiveXObject('Msxml2.XMLHTTP') ) : new XMLHttpRequest();

            xhr.open( 'GET', url, true );
            xhr.onreadystatechange = function() {
                if ( xhr.readyState === 4 ){
                    callback(xhr, url);
                } // else { callback function on AJAX error }
            };

            xhr.send( null );
        } catch (e){
            if ( window.XDomainRequest ) {
                var xdr = new XDomainRequest();
                xdr.open('get', url);
                xdr.onload = function() {
                    callback(xdr, url);
                };
                xdr.onerror = function() {
                    return false; // xdr load fail
                };
                xdr.send();
            }
        }
    },

    // Remove queries.
    removeMediaQueries = function(css) {
        // Test for Media Query support
        if ( !window.matchMedia && !window.msMatchMedia ) {
            // If the browser doesn't support media queries, we find all @media declarations in the CSS and remove them.
            // Note: Since @rules can't be nested in the CSS spec, we're safe to just check for the closest following "}}" to the "@media".
            css = css.replace(/@media[\s\S]*?\}\s*\}/g, "");
        }

        return css;
    };

    if( !cssremunit() ){ // this checks if the rem value is supported
        var rules = '', // initialize the rules variable in this scope so it can be used later
            links = isStyleSheet(), // initialize the array holding the sheets urls for use later
            importLinks = [], //initialize the array holding the import sheet urls for use later
            found = [], // initialize the array holding the found rules for use later
            foundProps = [], // initialize the array holding the found properties for use later
            preCSS = [], // initialize array that holds css before being parsed
            CSSLinks = [], //initialize array holding css links returned from xhr
            css = [], // initialize the array holding the parsed rules for use later
            fontSize = '';

        // Notice: rem is a "root em" that means that in case when html element size was changed by css
        // or style we should not change document.documentElement.fontSize to 1em - only body size should be changed
        // to 1em for calculation

        fontSize = (function () {
            var doc = document,
                docElement = doc.documentElement,
                body = doc.body || doc.createElement('body'),
                isFakeBody = !doc.body,
                div = doc.createElement('div'),
                currentSize = body.style.fontSize,
                size;

            if ( isFakeBody ) {
                docElement.appendChild( body );
            }

            div.style.cssText = 'width:1em; position:absolute; visibility:hidden; padding: 0;';

            body.style.fontSize = '1em';

            body.appendChild( div );
            size = div.offsetWidth;

            if ( isFakeBody ) {
                docElement.removeChild( body );
            }
            else {
                body.removeChild( div );
                body.style.fontSize = currentSize;
            }

            return size;
        }());

        processLinks();
    } // else { do nothing, you are awesome and have REM support }

})(window);


/*
// @name: Responsive-img.js
// @version: 1.1
// 
// Copyright 2013-2014 Koen Vendrik, http://kvendrik.com
// Licensed under the MIT license
*/

	function makeImagesResponsive(){

			var viewport = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;

		////////GET ALL IMAGES////////

		var images = document.getElementsByTagName('body')[0].getElementsByTagName('img');
		if( images.length === 0 ){
			return;
		}

		////////HASATTR FUNCTION////////

		var hasAttr;
		if(!images[0].hasAttribute){ //IE <=7 fix

			hasAttr = function(el, attrName){ //IE does not support Object.Prototype
				return el.getAttribute(attrName) !== null;
			};

		} else {

			hasAttr = function(el, attrName){
				return el.hasAttribute(attrName);
			};

		}

		////////CHECK IF DISPLAY IS RETINA////////

		var retina = window.devicePixelRatio ? window.devicePixelRatio >= 1.2 ? 1 : 0 : 0;

		////////LOOP ALL IMAGES////////

		for (var i = 0; i < images.length; i++) {

				var image = images[i];


				//set attr names

				var srcAttr = ( retina && hasAttr(image, 'data-src2x') ) ? 'data-src2x' : 'data-src';
				var baseAttr = ( retina && hasAttr(image, 'data-src-base2x') ) ? 'data-src-base2x' : 'data-src-base';

				//check image attributes

				if( !hasAttr(image, srcAttr) ){
					continue;
				}

				var basePath = hasAttr(image, baseAttr) ? image.getAttribute(baseAttr) : '';


				//get attributes

				var queries = image.getAttribute(srcAttr);



				//split defined query list

					var queries_array = queries.split(',');

				//loop queries

				for(var j = 0; j < queries_array.length; j++){

					//split each individual query
					var query = queries_array[j].replace(':','||').split('||');

					//get condition and response
					var condition = query[0];
					var response = query[1];


					//set empty variables
					var conditionpx;
					var bool;


					//check if condition is below
					if(condition.indexOf('<') !== -1){

						conditionpx = condition.split('<');

						if(queries_array[(j -1)]){

							var prev_query = queries_array[(j - 1)].split(/:(.+)/);
							var prev_cond = prev_query[0].split('<');

							bool =  (viewport <= conditionpx[1] && viewport > prev_cond[1]);

						} else {

							bool =  (viewport <= conditionpx[1]);

						}

					} else {

						conditionpx = condition.split('>');

						if(queries_array[(j +1)]){

							var next_query = queries_array[(j +1)].split(/:(.+)/);
							var next_cond = next_query[0].split('>');
							
							bool = (viewport >= conditionpx[1] && viewport < next_cond[1]);

						} else {

							bool = (viewport >= conditionpx[1]);

						}

					}


					//check if document.width meets condition
					if(bool){

						var isCrossDomain = response.indexOf('//') !== -1 ? 1 : 0;

						var new_source;
						if(isCrossDomain === 1){
							new_source = response;
						} else {
							new_source = basePath + response;
						}

						if(image.src !== new_source){

							//change img src to basePath + response
							image.setAttribute('src', new_source);

						}

						//break loop
						break;
					}

				}


		}

	}

if(window.addEventListener){

	window.addEventListener('load', makeImagesResponsive, false);
	window.addEventListener('resize', makeImagesResponsive, false);

} else { //ie <=8 fix

	window.attachEvent('onload', makeImagesResponsive);
	window.attachEvent('onresize', makeImagesResponsive);

}

// on off click mouseover mouseout focus blur submit keydown keyup
// find eq filter first last parent parents children firstChild lastChild siblings prev prevAll next nextAll
// hide show fadeIn remove 
// text html attr css addClass removeClass toggleClass hasClass 
// outerWidth outerHeight getTop getLeft offset(left top)
// before after append prepend

// READY
// HELPER FUNCTIONS
// LANGUAGE EXTENSIONS
// KIT START
// DOM MANIPULATION
// HANDLE ATTR
// STYLE INSTANCE METHODS
// STYLE INSTANCE METHODS
// HANDLE NODE
// GET ELEMENT SIZE
// GET WINDOW SIZE

// ========== READY ==========
// Author: Diego Perini (diego.perini at gmail.com)
// Summary: cross-browser wrapper for DOMContentLoaded
// URL: https://github.com/dperini/ContentLoaded/blob/master/src/contentloaded.js
function ready(fn) {
	var win = window, 
	done = false, 
	top = true,
	doc = win.document,
	root = doc.documentElement,
	modern = doc.addEventListener,
	add = modern ? 'addEventListener' : 'attachEvent',
	rem = modern ? 'removeEventListener' : 'detachEvent',
	pre = modern ? '' : 'on',
	init = function(e) {
		if (e.type === 'readystatechange' && doc.readyState !== 'complete') {return;}
		(e.type === 'load' ? win : doc)[rem](pre + e.type, init, false);
		if (!done && (done = true)) {fn.call(win, e.type || e);}
	},
	poll = function() {
		try { root.doScroll('left'); } catch(e) { setTimeout(poll, 50); return; }
		init('poll');
	};
	if (doc.readyState === 'complete') { fn.call(win, 'lazy'); }
	else {
		if (!modern && root.doScroll) {
			try { top = !win.frameElement; } catch(e) { }
			if (top) { poll(); }
		}
		doc[add](pre + 'DOMContentLoaded', init, false);
		doc[add](pre + 'readystatechange', init, false);
		win[add](pre + 'load', init, false);
	}
}

// ========== HELPER FUNCTIONS ==========
function toCamelCase(str) {
	return str.replace(/-([a-z])/ig, function( all, letter ) {
		return letter.toUpperCase();
	});
}

var getStyle = (function() {
	if (typeof getComputedStyle !== "undefined") {
		return function(el, cssProp) {
			return window.getComputedStyle(el, null).getPropertyValue(cssProp);
		};
	} else {
		return function(el, cssProp) {
			return el.currentStyle[toCamelCase(cssProp)];
		};
	}
}());

// ========== LANGUAGE EXTENSIONS ==========
if (typeof String.prototype.trim === "undefined") {
	String.prototype.trim = function() {
		return this.replace( /^\s+/, "" ).replace( /\s+$/, "" );
	};
}

if (typeof Array.prototype.indexOf !== 'function') {
	Array.prototype.indexOf = function (item) {
		for(var i = 0; i < this.length; i++) {
			if (this[i] === item) {
				return i;
			}
		}
		return -1;
	}; 
}

// ========== KIT START ==========
// (function (window, undefined) {
var dome = function (args, el) {
	if ( args.length > 0 ) {
		for (var i = 0; i < args.length; i++) {
			el[i] = args[i];
		}
		el.length = args.length;
	}
};

var k = function (selector) {
	if ( window === this ) {return new k(selector); }
	var type = typeof selector;
	if (type === 'string') {
		var result = document.querySelectorAll(selector);
		dome(result, this);
	} else if (type === "object" && selector.nodeType !== "undefined" && selector.nodeType === 1) {
		this[0] = selector;
		this.length = 1;
	}
	return this;
};

// ========= UTILS =========
var whitespace = "[\\x20\\t\\r\\n\\f]",
characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
identifier = characterEncoding.replace( "w", "w#" ),
attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
	"*([*^$|!~]?=)" + whitespace +
	"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
	"*\\]",
ID = new RegExp( "^#(" + characterEncoding + ")" ),
CLASS = new RegExp( "^\\.(" + characterEncoding + ")" ),
TAG = new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
ATTR = new RegExp( "^" + attributes );

k.filter = function (selector, els) {
	var match = [];
	if (selector.match(TAG)) {
		for (var i = 0; i < els.length; i++) {
			if(els[i].tagName.toLowerCase() === selector.replace(/(^\s*)|(\s*$)/g, '')){
				match.push(els[i]);
			}
		}
	} else if(selector.match(CLASS)){
		for (var j = 0; j < els.length; j++) {
			if ((" " + els[j].className + " ").indexOf(" " + selector.replace(/(^\s*\.)|(\s*$)/g, '') + " ") > -1) {
				match.push(els[j]);
			}
		}
	} else if(selector.match(ID)){
		for (var k = 0; k < els.length; k++) {
			if ((" " + els[k].getAttribute('id') + " ").indexOf(" " + selector.replace(/(^\s*\#)|(\s*$)/g, '') + " ") > -1) {
				match.push(els[k]);
			}
		}
	} else if(selector.match(ATTR)){
		for (var q = 0; q < els.length; q++) {
			if (els[q].hasAttribute(selector.replace(/(^\s*\[)|(\]\s*$)/g, ''))) {
				match.push(els[q]);
			}
		}
	}

	return match;
};

k.prototype.map = function (callback) {
	var results = [];
	for (var i = 0; i < this.length; i++) {
		results.push(callback.call(this, this[i], i));
	}
	return results;
};

k.prototype.mapOne = function (callback) {
	var m = this.map(callback);
	return m.length > 1 ? m : m[0];
};

k.prototype.forEach = function (callback) {
	this.map(callback);
	return this; 
};

k.prototype.filter = function (selector) {
	var results = k.filter(selector, this);

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

// ========= EVENT STATIC METHODS =========
if (typeof addEventListener !== "undefined") {
	k.addEvent = function(obj, evt, fn) {
		obj.addEventListener(evt, fn, false);
	};

	k.removeEvent = function(obj, evt, fn) {
		obj.removeEventListener(evt, fn, false);
	};
} else if (typeof attachEvent !== "undefined") {
	k.addEvent = function(obj, evt, fn) {
		var fnHash = "e_" + evt + fn;

		obj[fnHash] = function() {
			var type = event.type,
				relatedTarget = null;

			if (type === "mouseover" || type === "mouseout") {
				relatedTarget = (type === "mouseover") ? event.fromElement : event.toElement;
			}
			
			fn.call(obj, {
				target : event.srcElement,
				type : type,
				relatedTarget : relatedTarget,
				_event : event,
				preventDefault : function() {
					this._event.returnValue = false;
				},
				stopPropagation : function() {
					this._event.cancelBubble = true;
				}
			});
		};

		obj.attachEvent("on" + evt, obj[fnHash]);
	};

	k.removeEvent = function(obj, evt, fn) {
		var fnHash = "e_" + evt + fn;

		if (typeof obj[fnHash] !== "undefined") {
			obj.detachEvent("on" + evt, obj[fnHash]);
			delete obj[fnHash];
		}
	};
} else {
	k.addEvent = function(obj, evt, fn) {
		obj["on" + evt] = fn;
	};

	k.removeEvent = function(obj, evt) {
		obj["on" + evt] = null;
	};
}

// ========= EVENT INSTANCE METHODS =========
k.prototype.on = function (evt, fn) {
	return this.forEach(function (el) {
		k.addEvent(el, evt, fn);
	});
};

k.prototype.off = function (evt, fn) {
	return this.forEach(function (el) {
		k.removeEvent(el, evt, fn);
	});
};

k.prototype.click = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'click', fn);
	});
};

k.prototype.mouseover = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'mouseover', fn);
	});
};

k.prototype.mouseout = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'mouseout', fn);
	});
};

k.prototype.focus = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'focus', fn);
	});
};

k.prototype.blur = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'blur', fn);
	});
};

k.prototype.submit = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'submit', fn);
	});
};

k.prototype.keydown = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'keydown', fn);
	});
};

k.prototype.keyup = function(fn) {
	return this.forEach(function (el) {
		k.addEvent(el, 'keyup', fn);
	});
};

// ========== DOM MANIPULATION ==========
k.prototype.hide = function() {
	return this.forEach(function (el) {
		el.style.display = 'none';
	});
};

k.prototype.show = function() {
	return this.forEach(function (el) {
		el.style.display = 'inherit';
	});
};

k.prototype.fadeIn = function (time) {
	return this.forEach(function (el) {
		var opacity = 0;

		el.style.opacity = 0;
		el.style.filter = '';

		var last = +new Date();
		var tick = function() {
		  opacity += (new Date() - last) / time;
		  el.style.opacity = opacity;
		  el.style.filter = 'alpha(opacity=' + (100 * opacity)|0 + ')';

		  last = +new Date();

		  if (opacity < 1) {
		    (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
		  }
		};

		tick();
	});
};

k.prototype.find = function (selector) {
	var results = [];
	if (typeof selector === 'string') {
		this.forEach(function (el) {
			var selection = el.querySelectorAll(selector);
			for (var i = 0; i < selection.length; i++) {
				results.push(selection[i]);
			}
		});
	}
	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.eq = function( args, i ) {
	if (args.length > i) {
		return k(args[i]);
	}
};

k.prototype.eq = function (i) {
	return k.eq(this, i);
};

k.prototype.first = function () {
	return k.eq(this, 0);
};

k.prototype.last = function () {
	return k.eq(this, this.length-1);
};

k.prototype.parent = function () {
	var results = [];
	this.forEach(function (el) {
		results.push(el.parentNode);
	});

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.prototype.prev = function () {
	var results = [];
	this.forEach(function (el) {
		do { el = el.previousSibling; } while ( el && el.nodeType !== 1 );
		results.push(el);
	});

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.prototype.next = function () {
	var results = [];
	this.forEach(function (el) {
		do { el = el.nextSibling; } while ( el && el.nodeType !== 1 );
		results.push(el);
	});

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.prototype.siblings = function (selector) {
	var results = [],
			type = typeof selector;
	this.forEach(function (el) {
		var siblings = el.parentNode.children;
		for (var i = 0; i < siblings.length; i++) {
			if (siblings[i] !== el) {
				results.push(siblings[i]);
			}
		}
	});
	if (type === 'string') {
		results = k.filter(selector, results);
	}

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.prototype.parents = function (selector) {
	if (typeof selector !== 'string') {return;}
	var results = [],
			parent = [];
	this.forEach(function (el) {
		while(el.parentNode && el.parentNode.tagName){
			parent.push(el.parentNode);
			el = el.parentNode;
		}
	});
	results = k.filter(selector, parent);

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.prototype.children = function (selector) {
	var children = [],
			type = typeof selector;
	this.forEach(function (el) {
		for (var i=el.children.length; i--;){
			if (el.children[i].nodeType === 1){
				children.unshift(el.children[i]);
			}
		}
	});
	if (type !== 'undefined' && type === 'string') {
		children = k.filter(selector, children);
	}

	if (children.length > 0) {
		dome(children, this);
		return this;
	} else { return; }
};

k.prototype.firstChild = function (selector) {
	var type = typeof selector;
	if (type !== 'undefined' && type === 'string') {
		return this.children(selector).eq(0);
	} else if(type === 'undefined'){
		return this.children().eq(0);
	}
};

k.prototype.lastChild = function (selector) {
	var type = typeof selector;
	if (type !== 'undefined' && type === 'string') {
		return this.children(selector).last();
	} else if(type === 'undefined'){
		return this.children().last();
	}
};

k.index = function(obj, current){
	for (var i = 0;i < obj.length; i++) {
		if (obj[i] === current) {
			return i;
		}
	}
};

k.prototype.prevAll = function () {
	var results = [];
	this.forEach(function (el) {
		var siblings = el.parentNode.children,
				index = k.index(siblings, el);
		for (var i = 0; i < index; i++) {
			results.push(siblings[i]);
		}
	});

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

k.prototype.nextAll = function () {
	var results = [];
	this.forEach(function (el) {
		var siblings = el.parentNode.children,
				index = k.index(siblings, el);
		for (var i = siblings.length-1; i > index; i--) {
			results.push(siblings[i]);
		}
	});

	if (results.length > 0) {
		dome(results, this);
		return this;
	} else { return; }
};

// ========== HANDLE ATTR ==========
k.prototype.text = function (text) {
	if (typeof text !== "undefined") {
		return this.forEach(function (el) {
			if (el.textContent) {
				el.textContent = text;
			} else{
				el.innerText = text;
			}
		});
	} else {
		return this.mapOne(function (el) {
			if (el.textContent) {
				return el.textContent;
			} else{
				return el.innerText;
			}
		});
	}
};

k.prototype.html = function (html) {
	if (typeof html !== "undefined") {
		return this.forEach(function (el) {
			el.innerHTML = html;
		});
	} else {
		return this.mapOne(function (el) {
			return el.innerHTML;
		});
	}
};

k.prototype.attr = function (attr, val) {
	if (typeof val !== 'undefined') {
		return this.forEach(function(el) {
			el.setAttribute(attr, val);
		});
	} else {
		return this.mapOne(function (el) {
			return el.getAttribute(attr);
		});
	}
};

// ========== STYLE INSTANCE METHODS ==========
k.css = function(el, css, value) {
	var cssType = typeof css,
		valueType = typeof value,
		elStyle = el.style;

	if (cssType !== "undefined" && valueType === "undefined") {
		if (cssType === "object") {
			// set style info
			for (var prop in css) {
				if (css.hasOwnProperty(prop)) {
					elStyle[toCamelCase(prop)] = css[prop];
				}
			}
		} else if (cssType === "string") {
			// get style info for specified property
			return getStyle(el, css);
		} else {
			throw { message: "Invalid parameter passed to css()" };
		}

	} else if (cssType === "string" && valueType === "string") {
		elStyle[toCamelCase(css)] = value;

	} else {
		throw { message: "Invalid parameters passed to css()" };
	}
};

k.hasClass = function(el, value) {   
	return (" " + el.className + " ").indexOf(" " + value + " ") > -1;
};

k.addClass = function(el, value) {
	var className = el.className;
	
	if (!className) {
		el.className = value;
	} else {
		var classNames = value.split(/\s+/),
			l = classNames.length;

		for ( var i = 0; i < l; i++ ) {		    
			if (!this.hasClass(el, classNames[i])) {
				className += " " + classNames[i];
			}
		}

		el.className = className.trim();
	}
};

k.removeClass = function(el, value) {
	if (value) {
		var classNames = value.split(/\s+/),
			className = " " + el.className + " ",
			l = classNames.length;

		for (var i = 0; i < l; i++) {
			className = className.replace(" " + classNames[i] + " ", " ");
		}

		el.className = className.trim();

	} else {
		el.className = "";
	}
};

k.toggleClass = function(el, value) {
	var classNames = value.split(/\s+/),
		i = 0,
		className;

	while (className = classNames[i++]) {
		this[this.hasClass(el, className) ? "removeClass" : "addClass"](el, className);
	}
};

// ========== STYLE INSTANCE METHODS ==========
k.prototype.css = function(css, value) {
	return this.forEach(function (el) {
		return k.css(el, css, value) || el;
	});
};

k.prototype.addClass = function(value) {
	return this.forEach(function (el) {
		k.addClass(el, value);
	});
};

k.prototype.removeClass = function(value) {
	return this.forEach(function (el) {
		k.removeClass(el, value);
	});
};

k.prototype.toggleClass = function(value) {
	return this.forEach(function (el) {
		k.toggleClass(el, value);
	});
};

k.prototype.hasClass = function(value) {
	return this.forEach(function (el) {
		k.hasClass(el, value);
	});
};

// ========== HANDLE NODE ==========
k.createElement = function(obj) {
	if (!obj || !obj.tagName) {
		throw { message : "Invalid argument" };
	}

	var el = document.createElement(obj.tagName);
	obj.id && (el.id = obj.id);
	obj.className && (el.className = obj.className);
	obj.html && (el.innerHTML = obj.html);
	
	if (typeof obj.attributes !== "undefined") {
		var attr = obj.attributes,
			prop;

		for (prop in attr) {
			if (attr.hasOwnProperty(prop)) {
				el.setAttribute(prop, attr[prop]);
			}
		}
	}

	if (typeof obj.children !== "undefined") {
		var child,
			i = 0;

		while (child = obj.children[i++]) {
			el.appendChild(this.createElement(child));
		}
	}

	return el;
};
// var el = k.createElement({
// 	tagName: 'div',
// 	id: 'foo',
// 	className: 'foo',
// 	children: [{
// 		tagName: 'div',
// 		html: '<b>Hello, creatElement</b>',
// 		attributes: {
// 			'am-button': 'primary'
// 		}
// 	}]
// });

k.prototype.clone = function () {
	return this.forEach(function (el) {
		el.cloneNode(true);
	});
};

k.prototype.remove = function () {
	return this.forEach(function (el) {
		return el.parentNode.removeChild(el);
	});
};

k.prototype.append = function(data) {
	if (typeof data.nodeType !== "undefined" && data.nodeType === 1) {
		return this.forEach(function (el) {
			el.appendChild(data);
		});
	// } else if (data instanceof k) {
	// 	return this.forEach(function (el) {
	// 		el.appendChild(data);
	// 	});
		// this.el.appendChild(data.el);
	} else if (typeof data === "string") {
		return this.forEach(function (el) {
			var html = el.innerHTML;
			el.innerHTML = html + data;
		});
	}
};

k.prototype.prepend = function(data) {
	if (typeof data.nodeType !== "undefined" && data.nodeType === 1) {
		return this.forEach(function (el) {
			el.insertBefore(data, el.firstChild);
		});
	} else if (typeof data === "string") {
		return this.forEach(function (el) {
			var html = el.innerHTML;
			el.innerHTML = data + html;
		});
	}
};

k.prototype.before = function (htmlString) {
	return this.forEach(function (el) {
		el.insertAdjacentHTML('beforebegin', htmlString);
	});
};

k.prototype.after = function (htmlString) {
	return this.forEach(function (el) {
		el.insertAdjacentHTML('afterend', htmlString);
	});
};

// ========== GET ELEMENT SIZE ==========
k.prototype.outerWidth = function () {
	return this.mapOne(function (el) {
		var box = el.getBoundingClientRect();
		var ow = box.width || (box.right - box.left);
		return ow;
	});
};

k.prototype.outerHeight = function () {
	return this.mapOne(function (el) {
		var box = el.getBoundingClientRect();
		var oh = box.height || (box.bottom - box.top);
		return oh;
	});
};

k.prototype.getTop = function () {
	return this.mapOne(function (el) {
		var actualTop = el.offsetTop, current = el.offsetParent;
		while (current !== null){
		actualTop += current.offsetTop;
		current = current.offsetParent;
		}
		return actualTop;
	});
};

k.prototype.getLeft = function () {
	return this.mapOne(function (el) {
		var actualLeft = el.offsetLeft, current = el.offsetParent;
		while (current !== null){
		actualLeft += current.offsetLeft;
		current = current.offsetParent;
		}
		return actualLeft;
	});
};

k.prototype.offset = function () {
	return this.mapOne(function (el) {
		var rect = el.getBoundingClientRect();
		var offset = {
		  top: rect.top + document.body.scrollTop,
		  left: rect.left + document.body.scrollLeft
		};
		return offset;
	});
};

// ========== GET WINDOW SIZE ==========
k.win = {
	W: function  () {
		var d = document, w = window,
		winW = w.innerWidth || d.documentElement.clientWidth || d.body.clientWidth;
		return winW;  
	},

	H: function () {
		var winH, d = document, w = window;
		if(w.innerHeight) { // all except IE
			winH = w.innerHeight;
		} else if (d.documentElement && d.documentElement.clientHeight) {
		// IE 6 Strict Mode
			winH = d.documentElement.clientHeight;
		} else if (d.body) { // other
			winH = d.body.clientHeight;
		}
		return winH;
	},

	ST: function () {
		var scrollTop = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
		return scrollTop;
	}
};

// 	window.k = k;
// })(window);

k.prototype.reach = function (edge,distance) {
  var winH = k.win.H(),
        target,
        elTop = k(this[0]).offset().top;
    switch (edge) {
      case 'top':
        target = distance;
        break;
      case 'middle':
        target = distance + (winH / 2);
        break;
      case 'bottom':
        target = distance + winH;
        break;
    }

    if (elTop < target) {
      return true;
    } else {
      return false;
    }
};

// <ul class="target">
//   <li>item1</li>
//   <li>item2</li>
//   <li>item3</li>
//   <li>item4</li>
// </ul>
// <ul class="content">
//   <li>content1</li>
//   <li>content2</li>
//   <li>content3</li>
//   <li>content4</li>
// </ul>

// window.onscroll = function () {
//   k('.target li').forEach(function (el) {
//     if (k(el).reach('middle',0)) {
//       k('.content li').eq(k.index(k('.target li'), el)).css('color', 'red');
//     } else {
//       k('.content li').eq(k.index(k('.target li'), el)).css('color', 'black');
//     }
//   })
// };

// ========== SCROLL TO ==========
function scroll(element, to, duration) {
  if (duration < 0) {return;}
  var difference = to - element.scrollTop;
  var perTick = difference / duration * 10;

  setTimeout(function() {
  element.scrollTop = element.scrollTop + perTick;
  if (element.scrollTop === to) {return;}
  scroll(element, to, duration - 10);
  }, 10);
}
function scrollTo (to,duration) {
  scroll(document.body, to, duration);
  scroll(document.documentElement, to, duration);
}


// ========== NUMINCREASE ==========
function numIncrease(element, from, to, duration){
  if (duration < 0) {return;}
  var difference = to - from,
      perTick = difference / duration * 10;

  setTimeout(function () {
    from += perTick;
    element.text(Math.round(from));
    if (from === to) { return; }
    numIncrease(element, from, to, duration - 10);
  }, 10);
};

// ========== ANIMATE ==========
function animate(el, attr, from, to, duration){
  if (duration < 0) {return;}
  if (typeof attr === "string") {
    var difference = to - from,
        perTick = difference / duration * 10;

    setTimeout(function () {
      from += perTick;
      el.style[toCamelCase(attr)] = from + 'px';
      if (from === to) { return; }
      animate(el, attr, from, to, duration - 10);
    }, 10);
  } else { throw { message: "Invalid parameters passed to css()" }; }
};

// function animate(el, attr, to, duration){
//   if (duration < 0) {return;}
//   if (typeof attr === "string") {
//     var from = parseFloat(getStyle(el, attr)),
//         difference = to - from,
//         perTick = difference / duration * 10;
//         alert(from);

//     setTimeout(function () {
//       from += perTick;
//       el.style[toCamelCase(attr)] = from + 'px';
//       if (from === to) { return; }
//       animate(el, attr, to, duration - 10);
//     }, 10);
//   } else { throw { message: "Invalid parameters passed to css()" }; }
// };

// ready(function () {
//   k('button').click(function() {
//     animate(k('.target')[0], 'height', k('.target').outerHeight(), 50, 500);
//   });
// })


// @codekit-prepend "core.js"
// @codekit-prepend "reach.js"
// @codekit-prepend "scrollTo.js"
// @codekit-prepend "numIncrease.js"
// @codekit-prepend "animate.js"

ready(function () {
  
  // open
  k('[data-icon-nav]').click(function() {
    k('body').addClass('mb-nav-show');
  });

  // close
  k('[data-page-cover],[data-nav-close]').click(function() {
    k('body').removeClass('mb-nav-show');
  });

  // data-icon-haschild
  k('[data-icon-haschild]').click(function() {
    k(this).siblings('[data-nav-subnav]').addClass('mb-subnav-show');
  });
  // nav-back
  k('[data-nav-back]').click(function() {
    k(this).parent().removeClass('mb-subnav-show');
  });

  // on-resize
  window.onresize = function () {
    var winW = k.win.W();
    if (winW > 1023) {
      k('body').removeClass('mb-nav-show');
    }
  };

});

ready(function () {

  // dropdown
  k('[data-dropdown-toggle]').click(function() {
    k(this).parent().toggleClass('dropdown-open');
  });
  
});

// @codekit-prepend "nav.js"
// @codekit-prepend "dropdown.js"


// @codekit-prepend "lib/Modernizr.js"
// @codekit-prepend "lib/rem.js"
// @codekit-prepend "lib/responsive-img.js"
// @codekit-prepend "kit/kit.js"
// @codekit-prepend "pure/pure.js"




